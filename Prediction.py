from numpy import loadtxt
from keras.models import load_model
import math
import collections
from sklearn.metrics import average_precision_score
from sklearn.model_selection import cross_val_score
from sklearn.metrics import precision_recall_curve
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_curve
from sklearn.metrics import f1_score
from sklearn.metrics import precision_score,recall_score
from sklearn.metrics import roc_auc_score,roc_curve
from sklearn.metrics import auc
import numpy as np
from sklearn.tree import DecisionTreeClassifier
import pandas as pd
import re
from publicsuffixlist import PublicSuffixList
from sklearn import preprocessing 
import sys
import tkinter as tk
from tkinter import ttk
from tkinter.ttk import Progressbar



class predict_c: 
      
    

    def pre_f(self,file_path):
        
        model = load_model('ANN_Model', compile = True)
        df=pd.read_csv(file_path)
        topLevelDomain = []
        with open('D:\\Malware_Detection\\tlds-alpha-by-domain.txt', 'r') as content:
            for line in content:
                topLevelDomain.append((line.strip('\n')))
        psl = PublicSuffixList()
        self.fil_data(df,psl,topLevelDomain)
        self.pre(df,file_path,model)

    def pre_f_s(self,dga_fam,domain):
        data = [[dga_fam,domain]] 
        df = pd.DataFrame(data, columns = ['DGA_family', 'Domain'])
        model = load_model('ANN_Model', compile = True)
        topLevelDomain = []
        with open('D:\\Malware_Detection\\tlds-alpha-by-domain.txt', 'r') as content:
            for line in content:
                topLevelDomain.append((line.strip('\n')))
        psl = PublicSuffixList()
        self.fil_data(df,psl,topLevelDomain)
        result = self.pre_s(df,model)
        return result

    def pre_s(self,df,model):
        y_pred1=model.predict(df)
        y_pred1 = y_pred1>0.5
        return y_pred1



    def pre(self,df,file_path,model):
        y_pred1=model.predict(df)
        y_pred1 = y_pred1>0.5
        df1=pd.read_csv(file_path)
        df1.drop(columns=["DGA_family"],axis=1,inplace=True)
        df1["Is_Malware"]=pd.DataFrame(y_pred1, columns = ['Is_Malware'])

        df1["Is_Malware"]= df1["Is_Malware"].apply(lambda x : self.result_con(x) )

        df1.to_csv('Prediction_Result.csv', index=False)


    def fil_data(self,df,psl,topLevelDomain):
        df = self.extract_features(df,psl,topLevelDomain)
        label_encoder = preprocessing.LabelEncoder() 
        label_encoder.classes_ = np.load('DGA_family_classes.npy',allow_pickle=True)
        df['DGA_family']= label_encoder.transform(df['DGA_family'])
        df['Domain']= label_encoder.fit_transform(df['Domain']) 
        df.drop(columns=["Domain"],axis=1,inplace=True)
        df.dropna()
        df.fillna(df.mean(), inplace=True)

    def result_con(self,x):
        if x == True :
            return "No"
        if x == False:
            return "Yes"





    def domain_length(self,domain):
      # Generate Domain Name Length (DNL)
        return len(domain)
    
    def subdomains_number(self,domain,psl):
      # Generate Number of Subdomains (NoS)
      subdomain = self.ignoreVPS(domain,psl)
      return (subdomain.count('.') + 1)
  
    def subdomain_length_mean(self,domain,psl):
    # enerate Subdomain Length Mean (SLM) 
        subdomain = self.ignoreVPS(domain,psl)
        result = (len(subdomain) - subdomain.count('.')) / (subdomain.count('.') + 1)
        return result

    def has_www_prefix(self,domain):
        # Generate Has www Prefix (HwP)
        if domain.split('.')[0] == 'www':
            return 1
        else:
            return 0

    def underscore_ratio(self,domain,psl):
        # Generate Underscore Ratio (UR) on dataset
        subString = self.ignoreVPS(domain,psl)
        result = subString.count('_') / (len(subString) - subString.count('.'))
        return result

    def ignoreVPS(self,domain,psl):
        # Return the rest of domain after ignoring the Valid Public Suffixes:
        validPublicSuffix = '.' + psl.publicsuffix(domain)
        if len(validPublicSuffix) < len(domain):
            # If it has VPS
            subString = domain[0: domain.index(validPublicSuffix)]  
        elif len(validPublicSuffix) == len(domain):
            return 0
        else:
            # If not
            subString = domain
        
        return subString

    def contains_digit(self,domain,psl):
        """
        Contains Digits 
        """
        subdomain = self.ignoreVPS(domain,psl)
        for item in subdomain:
            if item.isdigit():
                return 1
        return 0

    def vowel_ratio(self,domain,psl):
        """
        calculate Vowel Ratio 
        """
        VOWELS = set('aeiou')
        v_counter = 0
        a_counter = 0
        subdomain = self.ignoreVPS(domain,psl)
        for item in subdomain:
            if item.isalpha():
                a_counter+=1
            if item in VOWELS:
                v_counter+=1
        if a_counter>1:
            ratio = v_counter/a_counter
            return ratio

    def contains_IP_address(self,domain):
        # Generate Contains IP Address (CIPA) on datasetx
        splitSet = domain.split('.')
        for element in splitSet:
            if(re.match("\d+", element)) == None:
                return 0
        return 1 
        
    def digit_ratio(self,domain,psl):
        """
        calculate digit ratio
        """
        d_counter = 0
        counter = 0
        subdomain = self.ignoreVPS(domain,psl)
        for item in subdomain:
            if item.isalpha() or item.isdigit():
                counter+=1
            if item.isdigit():
                d_counter+=1
        if counter>1:
            ratio = d_counter/counter
            return ratio

    def typeTo_Binary(self,type):
        # Convert Type to Binary variable DGA = 1, Normal = 0
        if type == 'DGA':
            return 1
        else:
            return 0

    def contains_single_character_subdomain(self,domain,psl):
    # Generate Contains Single-Character Subdomain (CSCS) 
        domain = self.ignoreVPS(domain,psl)
        str_split = domain.split('.')
        minLength = len(str_split[0])
        for i in range(0, len(str_split) - 1):
            minLength = len(str_split[i]) if len(str_split[i]) < minLength else minLength
        if minLength == 1:
            return 1
        else:
            return 0
        
    def contains_TLD_subdomain(self,domain,psl,topLevelDomain):
    # Generate Contains TLD as Subdomain (CTS)
        subdomain = self.ignoreVPS(domain,psl)
        str_split = subdomain.split('.')
        for i in range(0, len(str_split) - 1):
            if str_split[i].upper() in topLevelDomain:
                return 1
        return 0

    def prc_rrc(self,domain,psl):
        """
        calculate the Ratio of Repeated Characters in a subdomain
        """
        subdomain = self.ignoreVPS(domain,psl)
        subdomain = re.sub("[.]", "", subdomain)
        char_num=0
        repeated_char_num=0
        d = collections.defaultdict(int)
        for c in list(subdomain):
            d[c] += 1
        for item in d:
            char_num +=1
            if d[item]>1:
                repeated_char_num +=1
        ratio = repeated_char_num/char_num
        return ratio

    def prc_rcc(self,domain,psl):
        """
        calculate the Ratio of Consecutive Consonants
        """
        VOWELS = set('aeiou')
        counter = 0
        cons_counter=0
        subdomain = self.ignoreVPS(domain,psl)
        for item in subdomain:
            i = 0
            if item.isalpha() and item not in VOWELS:
                counter+=1
            else:
                if counter>1:
                    cons_counter+=counter
                counter=0
            i+=1
        if i==len(subdomain) and counter>1:
            cons_counter+=counter
        ratio = cons_counter/len(subdomain)
        return ratio

    def prc_rcd(self,domain,psl):
        """
        calculate the ratio of consecutive digits
        """
        counter = 0
        digit_counter=0
        subdomain = self.ignoreVPS(domain,psl)
        for item in subdomain:
            i = 0
            if item.isdigit():
                counter+=1
            else:
                if counter>1:
                    digit_counter+=counter
                counter=0
            i+=1
        if i==len(subdomain) and counter>1:
            digit_counter+=counter
        ratio = digit_counter/len(subdomain)
        return ratio

    def has_hvltd(self,domain,topLevelDomain):
        # Generate Has a Valid Top Level Domain (HVTLD)
        if domain.split('.')[len(domain.split('.')) - 1].upper() in topLevelDomain:
            return 1
        else:
            return 0

    def prc_entropy(self,domain,psl):
        """
        calculate the entropy of subdomain
        :param domain_str: subdomain
        :return: the value of entropy
        """
        subdomain = self.ignoreVPS(domain,psl)
        # get probability of chars in string
        prob = [float(subdomain.count(c)) / len(subdomain) for c in dict.fromkeys(list(subdomain))]

        # calculate the entropy
        entropy = - sum([p * math.log(p) / math.log(2.0) for p in prob])
        return entropy

    def extract_features(self,df,psl,topLevelDomain):
        df['DNL'] = df['Domain'].apply(lambda x: self.domain_length(x))
        df['NoS'] = df['Domain'].apply(lambda x: self.subdomains_number(x,psl))
        df['SLM'] = df['Domain'].apply(lambda x: self.subdomain_length_mean(x,psl))
        df['HwP'] = df['Domain'].apply(lambda x: self.has_www_prefix(x))
        df['HVTLD'] = df['Domain'].apply(lambda x: self.has_hvltd(x,topLevelDomain))
        df['CSCS'] = df['Domain'].apply(lambda x: self.contains_single_character_subdomain(x,psl))
        df['CTS'] = df['Domain'].apply(lambda x: self.contains_TLD_subdomain(x,psl,topLevelDomain))
        df['UR'] = df['Domain'].apply(lambda x: self.underscore_ratio(x,psl))
        df['CIPA'] = df['Domain'].apply(lambda x: self.contains_IP_address(x))
        df['contains_digit']= df['Domain'].apply(lambda x:self.contains_digit(x,psl))
        df['vowel_ratio']= df['Domain'].apply(lambda x:self.vowel_ratio(x,psl))
        df['digit_ratio']= df['Domain'].apply(lambda x: self.digit_ratio(x,psl))
        df['RRC']= df['Domain'].apply(lambda x: self.prc_rrc(x,psl))
        df['RCC']= df['Domain'].apply(lambda x: self.prc_rcc(x,psl))
        df['RCD']= df['Domain'].apply(lambda x: self.prc_rcd(x,psl))
        df['Entropy']= df['Domain'].apply(lambda x: self.prc_entropy(x,psl))
        return df



























